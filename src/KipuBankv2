// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title KipuBankV2
 * @notice Contrato inteligente que permite dep칩sitos y retiros en ETH y tokens ERC-20,
 *         con control de acceso, integraci칩n con or치culos Chainlink, contabilidad en USD
 *         y manejo de decimales normalizados.
 */

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract KipuBankV2 is AccessControl, ReentrancyGuard {
    // ------------------------------------------------------------
    // 游댳 ROLES
    // ------------------------------------------------------------
    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    // ------------------------------------------------------------
    // 游댳 ERRORES PERSONALIZADOS
    // ------------------------------------------------------------
    error InvalidTokenAddress();
    error InsufficientBalance();
    error ExceedsWithdrawLimit();
    error ExceedsBankCap();
    error TransferFailed();
    error InvalidOracle();

    // ------------------------------------------------------------
    // 游댳 ESTRUCTURAS Y TIPOS
    // ------------------------------------------------------------
    struct TokenOracle {
        AggregatorV3Interface priceFeed; // Or치culo de precios del token
        uint8 decimals; // Decimales del token ERC20
    }

    // ------------------------------------------------------------
    // 游댳 VARIABLES INMUTABLES Y CONSTANTES
    // ------------------------------------------------------------
    uint256 public immutable bankCapUSD; // L칤mite total del banco expresado en USD (8 decimales)
    uint256 public immutable perTxWithdrawLimitUSD; // L칤mite por transacci칩n en USD (8 decimales)
    AggregatorV3Interface public immutable ethUsdFeed; // Or치culo ETH/USD

    address public constant NATIVE_TOKEN = address(0); // Identificador del token nativo (ETH)
    uint8 public constant USD_DECIMALS = 6; // Decimales est치ndar de contabilidad interna

    // ------------------------------------------------------------
    // 游댳 MAPPINGS
    // ------------------------------------------------------------
    mapping(address => mapping(address => uint256)) private vaultBalances; 
    // usuario => (token => saldo)

    mapping(address => TokenOracle) public tokenOracles; 
    // token => or치culo y decimales

    // ------------------------------------------------------------
    // 游댳 EVENTOS
    // ------------------------------------------------------------
    event Deposit(address indexed user, address indexed token, uint256 amount, uint256 valueUSD);
    event Withdrawal(address indexed user, address indexed token, uint256 amount, uint256 valueUSD);
    event OracleUpdated(address indexed token, address indexed feed);

    // ------------------------------------------------------------
    // 游댳 CONSTRUCTOR
    // ------------------------------------------------------------
    constructor(
        uint256 _bankCapUSD,
        uint256 _perTxWithdrawLimitUSD,
        address _ethUsdFeed
    ) {
        if (_ethUsdFeed == address(0)) revert InvalidOracle();

        bankCapUSD = _bankCapUSD;
        perTxWithdrawLimitUSD = _perTxWithdrawLimitUSD;
        ethUsdFeed = AggregatorV3Interface(_ethUsdFeed);

        // Asignaci칩n de roles
        _grantRole(AccessControl.DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MANAGER_ROLE, msg.sender);
    }

    // ------------------------------------------------------------
    // 游댳 FUNCIONES P칔BLICAS: DEP칍SITO Y RETIRO
    // ------------------------------------------------------------

    /**
     * @notice Deposita ETH o tokens ERC-20 en el banco.
     * @param token Direcci칩n del token (usar address(0) para ETH)
     * @param amount Cantidad a depositar
     */
    function deposit(address token, uint256 amount) external payable nonReentrant {
        uint256 valueUSD;

        if (token == NATIVE_TOKEN) {
            // Depositar ETH
            require(msg.value == amount, "ETH mismatch");
            valueUSD = _convertToUSD(amount, ethUsdFeed, 18);
        } else {
            // Depositar ERC-20
            IERC20(token).transferFrom(msg.sender, address(this), amount);

            TokenOracle memory oracle = tokenOracles[token];
            if (address(oracle.priceFeed) == address(0)) revert InvalidOracle();

            valueUSD = _convertToUSD(amount, oracle.priceFeed, oracle.decimals);
        }

        // Validaci칩n de l칤mites
        if (getTotalBankValueUSD() + valueUSD > bankCapUSD) revert ExceedsBankCap();

        vaultBalances[msg.sender][token] += amount;

        emit Deposit(msg.sender, token, amount, valueUSD);
    }

    /**
     * @notice Retira ETH o tokens ERC-20.
     * @param token Direcci칩n del token (usar address(0) para ETH)
     * @param amount Cantidad a retirar
     */
    function withdraw(address token, uint256 amount) external nonReentrant {
        uint256 balance = vaultBalances[msg.sender][token];
        if (balance < amount) revert InsufficientBalance();

        uint256 valueUSD;

        if (token == NATIVE_TOKEN) {
            valueUSD = _convertToUSD(amount, ethUsdFeed, 18);
        } else {
            TokenOracle memory oracle = tokenOracles[token];
            if (address(oracle.priceFeed) == address(0)) revert InvalidOracle();
            valueUSD = _convertToUSD(amount, oracle.priceFeed, oracle.decimals);
        }

        if (valueUSD > perTxWithdrawLimitUSD) revert ExceedsWithdrawLimit();

        vaultBalances[msg.sender][token] -= amount;

        // Patr칩n Checks-Effects-Interactions
        if (token == NATIVE_TOKEN) {
            (bool success, ) = payable(msg.sender).call{value: amount}("");
            if (!success) revert TransferFailed();
        } else {
            bool sent = IERC20(token).transfer(msg.sender, amount);
            if (!sent) revert TransferFailed();
        }

        emit Withdrawal(msg.sender, token, amount, valueUSD);
    }

    // ------------------------------------------------------------
    // 游댳 FUNCIONES ADMINISTRATIVAS
    // ------------------------------------------------------------

    /**
     * @notice Registra o actualiza un or치culo de precios para un token ERC-20.
     */
    function setTokenOracle(
        address token,
        address feed,
        uint8 decimals_
    ) external onlyRole(MANAGER_ROLE) {
        if (token == address(0) || feed == address(0)) revert InvalidOracle();

        tokenOracles[token] = TokenOracle({
            priceFeed: AggregatorV3Interface(feed),
            decimals: decimals_
        });

        emit OracleUpdated(token, feed);
    }

    // ------------------------------------------------------------
    // 游댳 FUNCIONES DE LECTURA
    // ------------------------------------------------------------

    function getVaultBalance(address user, address token) external view returns (uint256) {
        return vaultBalances[user][token];
    }

    /**
     * @notice Obtiene el valor total del banco en USD (8 decimales Chainlink).
     */
    function getTotalBankValueUSD() public view returns (uint256 totalValueUSD) {
        // Esta funci칩n podr칤a ampliarse para iterar sobre todos los tokens registrados
        // pero se omite por simplicidad (requerir칤a una lista de tokens).
        return totalValueUSD;
    }

    /**
     * @notice Convierte una cantidad de un token a USD usando Chainlink.
     */
    function getPriceUSD(address token) external view returns (uint256 price, uint8 decimals_) {
        if (token == NATIVE_TOKEN) {
            (, int256 p,,,) = ethUsdFeed.latestRoundData();
            price = uint256(p);
            decimals_ = ethUsdFeed.decimals();
        } else {
            TokenOracle memory oracle = tokenOracles[token];
            (, int256 p,,,) = oracle.priceFeed.latestRoundData();
            price = uint256(p);
            decimals_ = oracle.priceFeed.decimals();
        }
    }

    // ------------------------------------------------------------
    // 游댳 FUNCIONES INTERNAS
    // ------------------------------------------------------------

    /**
     * @notice Convierte un valor en token a su valor en USD ajustando decimales.
     * @param amount Cantidad de token
     * @param feed Or치culo Chainlink del token
     * @param tokenDecimals Decimales del token original
     */
    function _convertToUSD(
        uint256 amount,
        AggregatorV3Interface feed,
        uint8 tokenDecimals
    ) internal view returns (uint256 valueUSD) {
        (, int256 price,,,) = feed.latestRoundData();
        require(price > 0, "Invalid price");

        uint8 priceDecimals = feed.decimals();
        // F칩rmula: (amount * price) / (10^(tokenDecimals + priceDecimals - USD_DECIMALS))
        valueUSD = (amount * uint256(price)) / (10 ** (tokenDecimals + priceDecimals - USD_DECIMALS));
    }

    // ------------------------------------------------------------
    // 游댳 Fallback y Receive
    // ------------------------------------------------------------
    receive() external payable {}
    fallback() external payable {}
}
